>*`Author: ACatSmiling`*
>
>*`Since: 2024-09-27`*

## 序列（sequence）

### 序列的概念

### 序列的通用操作

序列的通用操作方法：

- `+`：可以将两个序列拼接为一个序列。
- `*`：可以将序列重复指定的次数。
- `in`：用来检查指定元素是否存在于序列中，如果存在，返回 True，否则返回 False。
- `not in`：用来检查指定元素是否不在序列中，如果不在，返回 True，否则返回 False。
- `len()`：函数获取序列的长度，即序列中的元素的个数。该长度值，是序列的最大索引加 1。
- `min()`：函数获取序列中的最小值。
- `max()`：函数获取序列中的最大值。
- 可以通过索引（index）来获取序列中的元素：
  - 语法：`序列[索引]`。
  - 索引是元素在序列中的位置，序列中的每一个元素都有一个索引。
  - **索引是从 0 开始的整数**，序列第一个位置索引为 0，第二个位置索引为 1，第三个位置索引为 2，以此类推。
  - 索引可以是负数，表示从后向前获取元素，-1 表示倒数第一个元素，-2 表示倒数第二个元素，以此类推。
  - 如果使用的索引超过了序列最大的范围，会抛出异常 `IndexError: list index out of range`。
- `s.index()`方法获取指定元素在序列中的第一次出现时索引。
  - 方法和函数基本上是一样，只不过方法必须通过`对象.方法()`的形式调用，方法实际上就是和对象关系紧密的函数。
  - `index()`的第二个参数，表示查找的起始位置，第三个参数，表示查找的结束位置。
  - 如果要获取序列中没有的元素，会抛出异常。
- `s.count()`方法统计指定元素在序列中出现的次数。

### 序列的切片

**`切片`**：指从现有序列中，获取一个子序列。

- 语法一：`序列[起始:结束]`。
  - 通过切片获取元素时，**会包括起始位置的元素，不会包括结束位置的元素。**
  - 做切片操作时，总会返回一个新的序列，但不会影响原来的序列。
  - 起始和结束位置的索引都可以省略不写。
    - 如果省略起始位置，则会从第一个元素开始截取。
    - 如果省略结束位置，则会一直截取到最后。
    - 如果起始位置和结束位置全部省略，则相当于创建了一个序列的副本。
- 语法二：`序列[起始:结束:步长]`。
  - 步长表示，每次获取元素的间隔，默认值是 1。
  - 步长不能是 0，但可以是负数。
  - 步长如果是负数，则从序列的后边向前边取元素。

### 序列的分类

#### 列表（list）

**`列表`**：是 Python 中的一个对象。

- 对象（object）就是内存中专门用来存储数据的一块区域，之前我们学习的对象，像数值，它只能保存一个单一的数据。
- 列表是用来存储对象的对象，列表中可以保存多个有序的数据。
- **列表中可以保存任意的对象**，但一般不会这样操作，尽可能保证列表中元素属性一致。

##### 列表的创建

语法：`列表名 = []`。

  - 创建一个空列表：`list_name = []`。
  - 创建一个包含元素的列表：`list_name = [value1, value2, value3, ...]`。
  - 一个列表中可以存储多个元素，也可以在创建列表时，来指定列表中的元素。


  - 当向列表中添加多个元素时，多个元素之间使用`,`隔开。


  - **列表中的对象都会按照插入的顺序存储到列表中**，第一个插入的对象保存到第一个位置，第二个保存到第二个位置，以此类推。

示例：

```python
my_list = []  # 创建了一个空列表
print(my_list, type(my_list))  # [] <class 'list'>

my_list = [10]  # 创建一个只包含一个元素的列表

my_list = [10, 20, 30, 40, 50]  # 创建了一个包含有 5 个元素的列表

# my_list = [10, 'hello', True, None, [1, 2, 3], print]  # 列表可以保存任意对象，但一般不会这样操作

print(my_list[4])  # 50

print((my_list[-2]))  # 40

print(len(my_list))  # 5
```

##### 列表的通用操作

示例：

```python
my_list = [1, 2, 3] + [4, 5, 6]
print(len(my_list))  # 6

my_list = [1, 2, 3] * 5
print(len(my_list))  # 15

stus = ['孙悟空', '猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精', '沙和尚', '沙和尚']
print('牛魔王' in stus)  # False
print('牛魔王' not in stus)  # True

arr = [10, 1, 2, 5, 100, 77]
print(min(arr), max(arr))  # 1 100

print(stus.index('沙和尚'))  # 2
print(stus.index('沙和尚', 3, 7))  # 6
# print(stus.index('牛魔王'))  # ValueError: '牛魔王' is not in list
print(stus.count('牛魔王'))  # 0
```

##### 列表的切片

示例：

```python
stus = ['孙悟空', '猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精']
print(stus[1:])  # ['猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精']
print(stus[:3])  # ['孙悟空', '猪八戒', '沙和尚']
print(stus[:])  # ['孙悟空', '猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精']
print(stus)  # ['孙悟空', '猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精']

print(stus[0:5:3])  # ['孙悟空', '唐僧']
# print(stus[::0])  # ValueError: slice step cannot be zero
print(stus[::-1])  # ['白骨精', '蜘蛛精', '唐僧', '沙和尚', '猪八戒', '孙悟空']，列表反转
```

##### 列表的元素修改

示例：

```python
stus = ['孙悟空', '猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精']

# 通过索引来修改元素
stus[0] = 'sunwukong'
stus[2] = '哈哈'
print(stus)  # ['sunwukong', '猪八戒', '哈哈', '唐僧', '蜘蛛精', '白骨精']

# 通过 del 来删除元素
del stus[2]  # 删除索引为 2 的元素
print(stus)  # ['sunwukong', '猪八戒', '唐僧', '蜘蛛精', '白骨精']

# 通过切片来修改列表
# 在给切片进行赋值时，只能使用序列
stus[0:2] = ['牛魔王', '红孩儿']  # 使用新的元素替换旧元素
print(stus)  # ['牛魔王', '红孩儿', '唐僧', '蜘蛛精', '白骨精']
stus[0:2] = ['牛魔王', '红孩儿', '二郎神', "sda"]  # 新元素的个数可以超过旧元素
print(stus)  # ['牛魔王', '红孩儿', '二郎神', 'sda', '唐僧', '蜘蛛精', '白骨精']
stus[0:0] = ['牛魔王']  # 向索引为 0 的位置插入元素
print(stus)  # ['牛魔王', '牛魔王', '红孩儿', '二郎神', 'sda', '唐僧', '蜘蛛精', '白骨精']

# 当设置了步长时，序列中元素的个数必须和切片中元素的个数一致
print(stus[::2])  # ['牛魔王', '红孩儿', 'sda', '蜘蛛精']，指定步长，切片中元素个数为 4
# stus[::2] = ['牛魔王', '红孩儿', '二郎神']  # 报错，序列中元素只有 3 个，ValueError: attempt to assign sequence of size 3 to extended slice of size 4

# 通过切片来删除元素
del stus[0:2]  # 删除头两个元素
print(stus)  # ['红孩儿', '二郎神', 'sda', '唐僧', '蜘蛛精', '白骨精']
del stus[::2]  # 隔一个删一个
print(stus)  # ['二郎神', '唐僧', '白骨精']
stus[1:3] = []  # 修改位置 1 和 2 的元素为空
print(stus)  # ['二郎神']

# 以上操作，只适用于可变序列
s = 'hello'
# s[1] = 'a'  # 不可变序列，无法通过索引来修改
# 可以通过 list() 函数将其他的序列转换为list
s = list(s)
print(s)  # ['h', 'e', 'l', 'l', 'o']
```

##### 列表的方法

示例：

```python
stus = ['孙悟空', '猪八戒', '沙和尚', '唐僧']

# append() 
# 向列表的最后添加一个元素
stus.append('唐僧1')
print(stus)  # ['孙悟空', '猪八戒', '沙和尚', '唐僧', '唐僧1']

# insert()
# 向列表的指定位置插入一个元素
# 参数：
#   1. 要插入的位置
#   2. 要插入的元素
stus.insert(2, '唐僧2')
print(stus)  # ['孙悟空', '猪八戒', '唐僧2', '沙和尚', '唐僧', '唐僧1']

# extend()
# 使用新的序列来扩展当前序列
# 需要一个序列作为参数，它会将该序列中的元素添加到当前列表中
stus.extend(['唐僧3', '白骨精'])  # 等同于：stus += ['唐僧3','白骨精']
print(stus)  # ['孙悟空', '猪八戒', '唐僧2', '沙和尚', '唐僧', '唐僧1', '唐僧3', '白骨精']

# pop()
# 根据索引删除并返回被删除的元素，如果不指定索引位置，则删除并返回最后一个元素
result = stus.pop(2)
print(result)  # 唐僧2
print(stus)  # ['孙悟空', '猪八戒', '沙和尚', '唐僧', '唐僧1', '唐僧3', '白骨精']
result = stus.pop()  # 删除并返回最后一个元素
print(result)  # 白骨精
print(stus)  # ['孙悟空', '猪八戒', '沙和尚', '唐僧', '唐僧1', '唐僧3']

# remove()
# 删除指定值的元素，如果相同值的元素有多个，只会删除第一个
stus.remove('猪八戒')
print(stus)  # ['孙悟空', '沙和尚', '唐僧', '唐僧1', '唐僧3']

# reverse()
# 用来反转列表
stus.reverse()
print(stus)  # ['唐僧3', '唐僧1', '唐僧', '沙和尚', '孙悟空']

# clear()
# 清空序列
stus.clear()
print(stus)  # []

# sort()
# 用来对列表中的元素进行排序，默认是升序排列
# 如果需要降序排列，则需要传递一个 reverse=True 作为参数
my_list = list('asnbdnbasdabd')
my_list.sort()
print(my_list)  # ['a', 'a', 'a', 'b', 'b', 'b', 'd', 'd', 'd', 'n', 'n', 's', 's']

my_list = [10, 1, 20, 3, 4, 5, 0, -2]
my_list.sort()
print(my_list)  # 升序：[-2, 0, 1, 3, 4, 5, 10, 20]
my_list.sort(reverse=True)
print(my_list)  # 降序：[20, 10, 5, 4, 3, 1, 0, -2]
```

##### 列表的遍历

示例：

```python
# 遍历列表，指的就是将列表中的所有元素取出来
# 创建列表
stus = ['孙悟空', '猪八戒', '沙和尚', '唐僧', '白骨精', '蜘蛛精']

# 遍历列表
# print(stus[0])
# print(stus[1])
# print(stus[2])
# print(stus[3])

# 通过 while 循环来遍历列表
i = 0
while i < len(stus):
    print(stus[i])
    i += 1

# 通过 for 循环来遍历列表
# 语法：
#   for 变量 in 序列 :
#       代码块
# for 循环的代码块会执行多次，序列中有几个元素就会执行几次
#   每执行一次就会将序列中的一个元素赋值给变量，所以我们可以通过变量，来获取列表中的元素
for s in stus:
    print(s)
```

##### 列表的可变对象说明

每个对象中都保存了三个数据：id（标识），type（类型）和 value（值）。

- **列表是一个可变对象**，比如 `a = [1, 2, 3]`。
- `a[0] = 10`：改对象。
  - 这个操作是在通过变量去修改对象的值。
  - 这种操作不会改变变量所指向的对象。
  - 当我们去修改对象时，如果有其他变量也指向了该对象，则修改也会在其他的变量中体现。

- `a = [4, 5, 6]`：改变量。
  - 这个操作是在给变量重新赋值。
  - 这种操作会改变变量所指向的对象。
  - 为一个变量重新赋值时，不会影响其他的变量。
- 一般只有在为变量赋值时才是修改变量，其余的都是修改对象。

示例：

```python
# 列表是可变对象
a = [1, 2, 3]
print('修改前：', a, id(a))  # 修改前： [1, 2, 3] 1322105181888

# 通过索引修改列表的值
a[0] = 10
print('修改后：', a, id(a))  # 修改后： [10, 2, 3] 1322105181888

# 为变量重新赋值
a = [4, 5, 6]
print('重新赋值：', a, id(a))  # 重新赋值： [4, 5, 6] 1322105180928

a = [1, 2, 3]
b = a  # a 和 b 指向同一个对象
print("a", a, id(a))  # a [1, 2, 3] 2222727763648
print("b", b, id(b))  # b [1, 2, 3] 2222727763648
b[0] = 10
print("a", a, id(a))  # a [10, 2, 3] 2222727763648
print("b", b, id(b))  # b [10, 2, 3] 2222727763648

b = [10, 2, 3]  # b 和 a 指向的不再是同一个对象
print("a", a, id(a))  # a [10, 2, 3] 2222727763648
print("b", b, id(b))  # b [10, 2, 3] 2222727762688
```

#### 元组（tuple）

##### 元组的创建

语法：`元组名 = ()`。

- 创建一个空元组：`tuple_name = ()`。
- 创建一个包含元素的元组：`tuple_name = (value1, value2, value3, ...)`。
- 元组是一个不可变的序列，它的操作的方式基本上和列表是一致的。在操作元组时，可以把元组当成是一个不可变的列表。
- 元组是不可变对象，不能尝试为元组中的元素重新赋值。一般当我们希望数据不改变时，就使用元组，其余情况都使用列表。
- 当元组不是空元组时，括号可以省略。如果元组不是空元组，它里边至少要有一个`,`。

示例：

```python
my_tuple = ()  # 创建了一个空元组
print(my_tuple, type(my_tuple))  # () <class 'tuple'>

my_tuple = (1, 2, 3, 4, 5)  # 创建了一个 5 个元素的元组

# 元组是不可变对象，不能尝试为元组中的元素重新赋值
# my_tuple[3] = 10  # TypeError: 'tuple' object does not support item assignment
# print(my_tuple[3])

# 当元组不是空元组时，括号可以省略
# 如果元组不是空元组，它里边至少要有一个 ","
my_tuple = 10, 20, 30, 40
print(my_tuple, type(my_tuple))  # (10, 20, 30, 40) <class 'tuple'>
my_tuple = 40,
print(my_tuple, type(my_tuple))  # (40,) <class 'tuple'>
```

##### 元组的解包（解构）

**`解包`**：指的是将元组当中每一个元素都赋值给一个变量。

- 利用元组的解包特性，可以直接交换 a 和 b 的值。说明：不光是元组，列表和字符串都能解包。
- 在对一个元组进行解包时，变量的数量必须和元组中的元素的数量一致。也可以在变量前边添加一个`*`，这样该变量将会获取元组中所有剩余的元素，但不能同时出现两个或以上的 "*变量"。

示例：

```python
my_tuple = 10, 20, 30, 40

# 元组的解包（解构）
a, b, c, d = my_tuple
print("a =", a)  # a = 10
print("b =", b)  # b = 20
print("c =", c)  # c = 30
print("d =", d)  # d = 40

# 利用元组的解包特性，可以直接交换 a 和 b 的值
a = 100
b = 300
a, b = b, a  # b, a 就是一个元组，通过解包赋值给 a, b
print(a, b)  # 300 100

my_tuple = 10, 20, 30, 40

# 在对一个元组进行解包时，变量的数量必须和元组中的元素的数量一致
# 也可以在变量前边添加一个 *，这样该变量将会获取元组中所有剩余的元素
a, b, *c = my_tuple
a, *b, c = my_tuple
*a, b, c = my_tuple
a, b, *c = [1, 2, 3, 4, 5, 6, 7]  # 对列表也可以解包
a, b, *c = 'hello world'  # 对字符串也可以解包
# 不能同时出现两个或以上的 *变量
# *a, *b, c = my_tuple  # SyntaxError: two starred expressions in assignment
print('a =', a)  # a = h
print('b =', b)  # b = e
print('c =', c)  # c = ['l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
```

## 字典（dict）

### 字典的概念

**`字典`**：属于一种新的数据结构，称为**映射（mapping）**。

- 字典的作用和列表类似，都是用来存储对象的容器。
- 列表存储数据的性能很好，但是查询数据的性能的很差。查询元素时，字典的效率是非常快的。
- 在字典中可以保存多个对象，每个对象都会有一个唯一的名字，通过这个唯一的名字可以快速的查找到指定的元素。
  - 这个唯一的名字，我们称其为`键（key）`，通过 key 可以快速的查询 value。
  - 这个对象，我们称其为`值（value）`。
  - 所以字典，我们也称为**键值对（key - value）结构**。
  - 每个字典中都可以有多个键值对，而每一个键值对我们称其为**一项（item）**。

### 字典的创建

语法一：`字典名 = {}`。

语法二：使用`dict()`函数。

- 创建一个空字典：`dict_name = {}`。
- 创建一个包含数据的字典：`dict_name = {k1: v1, k2: v2, k3: v3, ...}`。
- 字典的键可以是任意的不可变对象（int、str、bool、tuple ...），但是一般我们都会使用 str。
- **字典的键是不能重复的**，如果出现重复，后边的会替换前边的。
- 字典的值可以是任意对象。

示例：

```python
# 方式一：使用 {} 来创建字典

d = {}  # 创建一个空字典

# 创建一个包含有数据的字典
d = {
    'name': '孙悟空',
    'age': 18,
    'gender': '男'
}
print(d, type(d))  # {'name': '孙悟空', 'age': 18, 'gender': '男'} <class 'dict'>

# 根据键来获取值
print(d['name'], d['age'], d['gender'])  # 孙悟空 18 男

# 如果使用了字典中不存在的键，会报错
# print(d['hello'])  # KeyError: 'hello'

############################################################################

# 方式二：使用 dict() 函数来创建字典

# 每一个参数都是一个键值对，参数名就是键，参数名就是值（这种方式创建的字典，key 都是字符串）
d = dict(name='孙悟空', age=18, gender='男')

# 也可以将一个包含有双值子序列的序列转换为字典
#   双值序列：序列中只有两个值，比如[1, 2]，('a', 3)，'ab'
#   子序列：如果序列中的元素也是序列，那么我们就称这个元素为子序列，比如[(1, 2), (3, 5)]
d = dict([('name', '孙悟空'), ('age', 18)])
```

### 字典的使用

```python
d = dict(name='孙悟空', age=18, gender='男')

# len()：获取字典中键值对的个数
print(len(d))  # 3

# in：检查字典中是否包含指定的键
# not in：检查字典中是否不包含指定的键
print('hello' in d)  # False
print('age' not in d)  # False

# 获取字典中的值，根据键来获取值
# 方式一：d[key]
#   通过 d[key] 来获取值时，如果键不存在，会抛出异常 KeyError
print(d['age'])  # 18
n = 'name'
print(d[n])  # 孙悟空

# 方式二：get(key[, default])，该方法用来根据键来获取字典中的值
#   如果获取的键在字典中不存在，会返回 None，不会报错
#   也可以指定一个默认值，来作为第二个参数，这样获取不到值时将会返回默认值
print(d.get('name'))  # 孙悟空
print(d.get('hello'))  # None
print(d.get('hello', '默认值'))  # 默认值

# 修改字典
# d[key] = value：如果 key 存在则覆盖，不存在则添加
d['name'] = 'sunwukong'  # 修改字典的 key-value
d['address'] = '花果山'  # 向字典中添加 key-value

# setdefault(key[, default])：可以用来向字典中添加 key-value
#   如果 key 已经存在于字典中，则返回 key 的值，不会对字典做任何操作
#   如果 key 不存在，则向字典中添加这个 key，并设置 value
result = d.setdefault('name', '猪八戒')
print('result =', result)  # result = sunwukong
result = d.setdefault('hello', '猪八戒')
print(d)  # {'name': 'sunwukong', 'age': 18, 'gender': '男', 'address': '花果山', 'hello': '猪八戒'}

# update([other])：将其他的字典中的 key-value 添加到当前字典中
#   如果有重复的 key，则后边的会替换到当前的
d = {'a': 1, 'b': 2, 'c': 3}
d2 = {'d': 4, 'e': 5, 'f': 6, 'a': 7}
d.update(d2)
print(d)  # {'a': 7, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}

# del：删除字典中的 key-value
del d['a']
del d['b']
print(d)  # {'c': 3, 'd': 4, 'e': 5, 'f': 6}
# del d['z']  # z 不存在，报错，KeyError: 'z'

# popitem()：随机删除字典中的一个键值对，一般都会删除最后一个键值对
#   删除之后，它会将删除的 key-value 作为返回值返回
#   返回的是一个元组，元组中有两个元素，第一个元素是删除的 key，第二个是删除的 value
#   当使用 popitem() 删除一个空字典时，会抛出异常 KeyError: 'popitem(): dictionary is empty'
# d.popitem()
result = d.popitem()
print(result)  # ('f', 6)
print(d)  # {'c': 3, 'd': 4, 'e': 5}

# pop(key[, default])：根据 key 删除字典中的 key-value，并将被删除的 value 返回
#   如果删除不存在的 key，会抛出异常
#   如果指定了默认值，再删除不存在的 key 时，不会报错，而是直接返回默认值
result = d.pop('d')
print(result)  # 4
print(d)  # {'c': 3, 'e': 5}
result = d.pop('z', '这是默认值')
print(result)  # 这是默认值
print(d)  # {'c': 3, 'e': 5}

# clear()：清空字典
d.clear()
print(d)  # {}

# print('result =',result)
# print(d)

# copy()：该方法用于对字典进行浅复制
#   复制以后的对象，和原对象是独立的，修改一个不会影响另一个
d = {'a': 1, 'b': 2, 'c': 3}
d2 = d.copy()  # d 和 d2 指向的是两个对象，这两个对象的值相同，id 不同
print('d = ', d, id(d))  # d =  {'a': 1, 'b': 2, 'c': 3} 1507616638400
print('d2 = ', d2, id(d2))  # d2 =  {'a': 1, 'b': 2, 'c': 3} 1507616638464

# 注意，浅复制会简单复制对象内部的值，如果值也是一个可变对象，这个可变对象不会被复制
# 深复制性能差，使用较少
d = {'a': {'name': '孙悟空', 'age': 18}, 'b': 2, 'c': 3}
d2 = d.copy()
print('d = ', d, id(d))  # d =  {'a': {'name': '孙悟空', 'age': 18}, 'b': 2, 'c': 3} 2538203734848
print('d2 = ', d2, id(d2))  # d2 =  {'a': {'name': '孙悟空', 'age': 18}, 'b': 2, 'c': 3} 2538210096768
# d 的 a 值也是一个字典，修改 d2 中 a 值列表中 name 的值，d 也会受到影响，说明浅复制不修改是可变对象的值
d2['a']['name'] = '猪八戒'
print('d = ', d, id(d))  # d =  {'a': {'name': '猪八戒', 'age': 18}, 'b': 2, 'c': 3} 2538203734848
print('d2 = ', d2, id(d2))  # d2 =  {'a': {'name': '猪八戒', 'age': 18}, 'b': 2, 'c': 3} 2538210096768

# d 的 a 值是一个列表
d = {'a': ['孙悟空', '猪八戒', '沙和尚'], 'b': 2, 'c': 3}
d2 = d.copy()
print('d = ', d, id(d))  # d =  {'a': ['孙悟空', '猪八戒', '沙和尚'], 'b': 2, 'c': 3} 2053189928960
print('d2 = ', d2, id(d2))  # d2 =  {'a': ['孙悟空', '猪八戒', '沙和尚'], 'b': 2, 'c': 3} 2053187068736
d2['a'][0] = '唐僧'
print('d = ', d, id(d))  # d =  {'a': ['唐僧', '猪八戒', '沙和尚'], 'b': 2, 'c': 3} 2053189928960
print('d2 = ', d2, id(d2))  # d2 =  {'a': ['唐僧', '猪八戒', '沙和尚'], 'b': 2, 'c': 3} 2053187068736
```

### 字典的遍历

```python
d = {'name': '孙悟空', 'age': 18, 'gender': '男'}

# 方式一：keys()
#   该方法会返回一个序列，序列中是字典中所有的键
for k in d.keys():
    print(k, d[k])

# 方式二：values()
#   该方法会返回一个序列，序列中是字典中所有的值
for v in d.values():
    print(v)

# 方式三：items()
#   该方法会返回字典中所有的项，它会返回一个序列，序列中是双值子序列
#   双值分别是，字典中的 key 和 value
print(d.items())  # dict_items([('name', '孙悟空'), ('age', 18), ('gender', '男')])
for k, v in d.items(): # 元组解包特性
    print(k, '=', v)
```

## 集合（set）

### 集合的概念

**`集合`**：和列表非常相似。

不同点：

- 集合中**只能存储不可变对象**。
- 集合中存储的对象是**无序**的（不是按照元素的插入顺序保存）。
- 集合中**不能出现重复的元素**。

### 集合的创建

语法一：`集合名 = {}`。

语法二：使用`set()`函数。

- **空集合只能通过 set() 来创建，{} 创建的是空字典。**

示例：

```python
# 方式一：使用 {} 来创建集合
s = {10, 3, 5, 1, 2, 1, 2, 3, 1, 1, 1, 1}
print(s, type(s))  # {1, 2, 3, 5, 10} <class 'set'>
# s = {[1, 2, 3], [4, 6, 7]}  # TypeError: unhashable type: 'list'，集合中只能存储不可变对象

############################################################################

# 方式二：使用 set() 函数来创建集合
s = set()  # 空集合只能通过 set() 来创建，{} 创建的是字典
# 可以通过 set() 来将序列和字典转换为集合
s = set([1, 2, 3, 4, 5, 1, 1, 2, 3, 4, 5])  # 转换列表
print(s)  # {1, 2, 3, 4, 5}
s = set('hello')  # 转换字符串
print(s)  # {'e', 'h', 'o', 'l'}
s = set({'a': 1, 'b': 2, 'c': 3})  # 转换字典，使用 set() 将字典转换为集合时，只会包含字典中的键
print(s)  # {'b', 'a', 'c'}
```

### 集合的使用

```python
############################################################################
s = {'a', 'b', 1, 2, 3, 1}
print(s)  # {1, 2, 3, 'a', 'b'}

# 使用 in 和 not in 来检查集合中的元素
print('a' in s)  # True
print('b' not in s)  # False

# 使用 len() 来获取集合中元素的数量
print(len(s))  # 5

# add()：向集合中添加元素
s.add(10)
s.add(30)
s.add(1)  # 集合中已存在的元素，添加无效
print(s)  # {1, 2, 3, 'a', 10, 'b', 30}

############################################################################
s = {'a', 'b', 1, 2, 3}

# update()：可以将一个集合中的元素添加到当前集合中，也可以传递序列或字典作为参数，字典只会添加键倒集合中
s2 = set('hello')  # 集合
s.update(s2)
print(s)  # {'a', 2, 3, 1, 'h', 'o', 'l', 'e', 'b'}

s = {'a', 'b', 1, 2, 3}
s.update((10, 20, 30, 40, 50))  # 元组
print(s)  # {'a', 2, 3, 1, 40, 10, 50, 20, 'b', 30}

s = {'a', 'b', 1, 2, 3}
s.update({10: 'ab', 20: 'bc', 100: 'cd', 1000: 'ef'})  # 字典
print(s)  # {'a', 2, 3, 1, 100, 1000, 10, 20, 'b'}

############################################################################
s = {'a', 'b', 1, 2, 3}

# {1, 2, 3, 100, 40, 'o', 10, 1000, 'a', 'h', 'b', 'l', 20, 50, 'e', 30}
# pop()：随机删除并返回一个集合中的元素
result = s.pop()
print(result)  # 1
print(s)  # {'a', 3, 2, 'b'}

# remove()：删除集合中的指定元素
s.remove('a')
print(s)  # {2, 3, 'b'}

# clear()：清空集合
s.clear()
print(s)  # set()

# copy()：对集合进行浅复制
```

### 集合的运算

在对集合做运算时，不会影响原来的集合，而是返回一个运算结果。

```python
# 创建两个集合
s = {1, 2, 3, 4, 5}
s2 = {3, 4, 5, 6, 7}

# &：交集运算
result = s & s2
print(result)  # {3, 4, 5}

# | 并集运算
result = s | s2
print(result)  # {1, 2, 3, 4, 5, 6, 7}

# -：差集
result = s - s2
print(result)  # {1, 2}

# ^：异或集，获取两个集合中只出现一次的元素
result = s ^ s2
print(result)  # {1, 2, 6, 7}

# <=：检查一个集合是否是另一个集合的子集
#   如果 a 集合中的元素全部都在 b 集合中出现，那么 a 集合就是 b 集合的子集，b 集合是 a 集合的超集
a = {1, 2, 3}
b = {1, 2, 3, 4, 5}
result = a <= b
print(result)  # True
result = {1, 2, 3} <= {1, 2, 3}
print(result)  # True
result = {1, 2, 3, 4, 5} <= {1, 2, 3}
print(result)  # False

# <：检查一个集合是否是另一个集合的真子集
#   如果超集 b 中含有子集 a 中所有元素，并且 b 中还有 a 中没有的元素，则 b 就是 a 的真超集，a 是 b 的真子集
result = {1, 2, 3} < {1, 2, 3}
print(result)  # False
result = {1, 2, 3} < {1, 2, 3, 4, 5}
print(result)  # True

# >=：检查一个集合是否是另一个的超集
result = {1, 2, 3, 4, 5} >= {1, 2, 3, 4, 5}
print(result)  # True

# >：检查一个集合是否是另一个的真超集
result = {1, 2, 3, 4, 5} > {1, 2, 3, 4, 5}
print(result)  # False
```

## 原文链接

https://github.com/ACatSmiling/zero-to-zero/blob/main/PythonLanguage/python.md