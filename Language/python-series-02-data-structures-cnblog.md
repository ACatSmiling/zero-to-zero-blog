>*`Author: ACatSmiling`*
>
>*`Since: 2024-09-27`*

Python 中的数据类型：

![1727533931777](https://img2023.cnblogs.com/blog/3488201/202409/3488201-20240928234347955-1827235969.jpg)

## 数值类型

### 整数（int）

**`整数`**：**Python 中，所有的整数都是 int 类型。**

- 可以表示正整数、负整数和零，没有小数部分。
- **Python 的整数没有大小限制。**
  - 在理论上，可以表示任意大的整数，不受计算机内存的限制。
  - Python 可以处理任意大小的整数，包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。
  - 某些语言的整数根据其存储长度是有大小限制的，例如 Java 对 32 位整数的范围限制在 -2147483648 ~ 2147483647。
  - 对于很大的数，例如 10000000000，很难数清楚 0 的个数。**Python 允许在数字中间以 _ 分隔**，因此，写成 10_000_000_000 和 10000000000 是完全一样的。十六进制数也可以写成 0xa1b2_c3d4。
- 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用`0x`前缀和 0 - 9，a - f 表示，例如：0xff00，0xa5b4c3d2，等等。
  - 十进制的数，不能以 0 开头。二进制以`0b`开头，八进制以`0o`开头，十六进制以`0x`开头。
  - 其他进制的整数，只要是数字，打印时一定是以十进制的形式显示的。

> **小整数的地址问题：**
>
> - Python 中的小整数，通常指的是`-5 ~ 256`之间的整数。
> - 当在 Python 中创建一个整数对象时，Python 会根据该整数的值动态地为其分配内存空间。对于小整数，Python 会使用一种称为`小整数缓存`的机制来优化内存使用。这个缓存池中的整数对象会被重复利用，而不是为每个新创建的小整数分配新的内存空间。这样可以减少内存分配和释放的开销，提高程序的性能。
> - 如果需要跟踪 Python 对象的内存地址，可以使用 Python 提供的内置函数 id() 来获取对象的唯一标识符，这个标识符通常可以用来近似地表示对象的内存地址。但是请注意，这个标识符并不是真正的内存地址，而是由 Python 解释器生成的一个唯一标识符，用于区分不同的对象实例。

### 浮点数（float）

**`浮点数`**：**Python 中，所有的浮点数都是 float 类型。**

- 可以表示带有小数部分的数值。

- **Python 的浮点数也没有大小限制。**

  - 如果超出一定范围，就会直接表示为`inf`（无限大）。

- 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23 x 10^9 和 12.3 x 10^8 是完全相等的。浮点数可以用数学写法，如 1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把 10 用 e 替代，1.23 x 10^9 就是 1.23e9，或者 12.3e8，0.000012 可以写成 1.2e-5，等等。

- 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而**浮点数运算则可能会有四舍五入的误差**，得到一个不精确的结果。

  ```python
  # 计算机无法精确表示所有的十进制小数，例如 0.1，这个小数在二进制中是一个无限循环小数
  # 在 Python 中表示 0.1 这个小数时，实际上得到的是一个近似值，而不是真正的 0.1
  print(0.1 + 0.2)  # 0.30000000000000004
  ```

  - 在Python中，有两种除法，一种除法是`/`，`/`除法的计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数。

    ```powershell
    >>> 10 / 3
    3.3333333333333335
    >>> 9 / 3
    3.0
    ```

  - 还有一种除法是`//`，称为地板除，`//`除法只取结果的整数部分。

    ```powershell
    >>> 10 // 3
    3
    >>> 9 // 3
    3
    ```

  - 相对于取整运算，Python 还提供一个余数运算，可以得到两个整数相除的余数。

    ```powershell
    >>> 10 % 3
    1
    >>> 9 % 3
    0
    ```

  - 无论整数做`//`除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。

### 复数（complex）

`复数`：由实数部分和虚数部分组成，用`a + bj`的形式表示，其中 a 和 b 是实数，j 是虚数单位。例如：e = 2 + 3j。

## 序列类型（sequence）

### 序列的概念

**`序列`**：序列是 Python 中最基本的一种数据结构，用于**保存一组有序的数据**。序列存储的数据，称为`元素`，所有的数据在序列当中都有一个`唯一的位置（索引）`，并且序列中的数据会按照添加的顺序来分配索引。

序列的可变性：

- **可变序列（序列中的元素可以改变）**

  - **列表（list）**

- **不可变序列（序列中的元素不能改变）**

  - **字符串（str）**
  - **元组（tuple）**

- `range()`函数：用来生成一个自然数的序列。

  ```python
  # range() 是一个函数，可以用来生成一个自然数的序列
  # 语法：range(start, end, [step=1])
  # 该函数需要三个参数
  #   1. 起始位置（包含，可以省略，默认是 0）
  #   2. 结束位置（不包含）
  #   3. 步长（可以省略，默认是 1）
  r = range(5)
  print(list(r))  # [0, 1, 2, 3, 4]
  r = range(0, 10, 2)
  print(list(r))  # [0, 2, 4, 6, 8]
  r = range(10, 0, -1)
  print(list(r))  # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  
  # 通过 range() 可以创建一个执行指定次数的 for 循环
  for i in range(30):
      print(i)
  ```

### 序列的通用操作

序列的通用操作方法：

- `+`：可以将两个序列拼接为一个序列。
- `*`：可以将序列重复指定的次数。
- `in`：用来检查指定元素是否存在于序列中，如果存在，返回 True，否则返回 False。
- `not in`：用来检查指定元素是否不在序列中，如果不在，返回 True，否则返回 False。
- `len()`：获取序列的长度，即序列中的元素的个数。该长度值，是序列的最大索引加 1。
- `min()`：获取序列中的最小值。
- `max()`：获取序列中的最大值。
- `del()`：删除序列中的特定元素。
- 可以通过索引（index）来获取序列中的元素：
  - 语法：`序列[索引]`。
  - 索引是元素在序列中的位置，序列中的每一个元素都有一个索引。
  - **索引是从 0 开始的整数**，序列第一个位置索引为 0，第二个位置索引为 1，第三个位置索引为 2，以此类推。
  - 索引可以是负数，表示从后向前获取元素，-1 表示倒数第一个元素，-2 表示倒数第二个元素，以此类推。
  - 如果使用的索引超过了序列最大的范围，会抛出异常 "IndexError: list index out of range"。
- `s.index()`方法获取指定元素在序列中的第一次出现时索引。
  - 方法和函数基本上是一样，只不过方法必须通过`对象.方法()`的形式调用，方法实际上就是和对象关系紧密的函数。
  - `index()`的第二个参数，表示查找的起始位置，第三个参数，表示查找的结束位置。
  - 如果要获取序列中没有的元素，会抛出异常。
- `s.count()`方法统计指定元素在序列中出现的次数。

### 序列的切片

**`切片`**：指从现有序列中，获取一个子序列。

- 语法一：`序列[起始:结束]`。
  - 通过切片获取元素时，**会包括起始位置的元素，不会包括结束位置的元素。**
  - 做切片操作时，总会返回一个新的序列，但不会影响原来的序列。
  - 起始和结束位置的索引都可以省略不写。
    - 如果省略起始位置，则会从第一个元素开始截取。
    - 如果省略结束位置，则会一直截取到最后。
    - 如果起始位置和结束位置全部省略，则相当于创建了一个序列的副本。
- 语法二：`序列[起始:结束:步长]`。
  - 步长表示，每次获取元素的间隔，默认值是 1。
  - 步长不能是 0，但可以是负数。
  - 步长如果是负数，则从序列的后边向前边取元素。

### 序列的分类

#### 列表（list）

**`列表`**：是 Python 中的一个对象。

- 对象（object）就是内存中专门用来存储数据的一块区域，之前我们学习的对象，像数值，它只能保存一个单一的数据。
- 列表是用来存储对象的对象，列表中可以**保存多个有序的数据**。
- **列表中可以保存任意的对象**，但一般不会这样操作，尽可能保证列表中元素属性一致。
- **列表的索引从 0 开始。**索引就是数据在列表中的位置编号，又可以被称为下标。注意：从列表中取值时，如果超出索引范围，程序会报错。

##### 列表的创建

语法：`列表名 = []`。

  - 创建一个空列表：`list_name = []`。
  - 创建一个包含元素的列表：`list_name = [value1, value2, value3, ...]`。
  - 一个列表中可以存储多个元素，也可以在创建列表时，来指定列表中的元素。


  - 当向列表中添加多个元素时，多个元素之间使用`,`隔开。


  - **列表中的对象都会按照插入的顺序存储到列表中**，第一个插入的对象保存到第一个位置，第二个保存到第二个位置，以此类推。

示例：

```python
my_list = []  # 创建了一个空列表
print(my_list, type(my_list))  # [] <class 'list'>

my_list = [10]  # 创建一个只包含一个元素的列表

my_list = [10, 20, 30, 40, 50]  # 创建了一个包含有 5 个元素的列表

# my_list = [10, 'hello', True, None, [1, 2, 3], print]  # 列表可以保存任意对象，但一般不会这样操作

print(my_list[4])  # 50

print((my_list[-2]))  # 40

print(len(my_list))  # 5
```

##### 列表的通用操作

列表的方法：

![1727537598738](https://img2023.cnblogs.com/blog/3488201/202409/3488201-20240928234347618-371881159.jpg)

示例：

```python
# 列表的加法
my_list = [1, 2, 3] + [4, 5, 6]
print(len(my_list))  # 6

# 列表的乘法
my_list = [1, 2, 3] * 5
print(len(my_list))  # 15

# 成员判断
stus = ['孙悟空', '猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精', '沙和尚', '沙和尚']
print('牛魔王' in stus)  # False
print('牛魔王' not in stus)  # True

arr = [10, 1, 2, 5, 100, 77]
print(min(arr), max(arr))  # 1 100

print(stus.index('沙和尚'))  # 2
print(stus.index('沙和尚', 3, 7))  # 6
# print(stus.index('牛魔王'))  # ValueError: '牛魔王' is not in list
print(stus.count('牛魔王'))  # 0
```

##### 列表的切片

示例：

```python
stus = ['孙悟空', '猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精']
print(stus[1:])  # ['猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精']
print(stus[:3])  # ['孙悟空', '猪八戒', '沙和尚']
print(stus[:])  # ['孙悟空', '猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精']
print(stus)  # ['孙悟空', '猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精']

print(stus[0:5:3])  # ['孙悟空', '唐僧']
# print(stus[::0])  # ValueError: slice step cannot be zero
print(stus[::-1])  # ['白骨精', '蜘蛛精', '唐僧', '沙和尚', '猪八戒', '孙悟空']，列表反转
```

##### 列表的元素修改

示例：

```python
stus = ['孙悟空', '猪八戒', '沙和尚', '唐僧', '蜘蛛精', '白骨精']

# 通过索引来修改元素
stus[0] = 'sunwukong'
stus[2] = '哈哈'
print(stus)  # ['sunwukong', '猪八戒', '哈哈', '唐僧', '蜘蛛精', '白骨精']

# 通过 del 来删除元素
del stus[2]  # 删除索引为 2 的元素
print(stus)  # ['sunwukong', '猪八戒', '唐僧', '蜘蛛精', '白骨精']

# 通过切片来修改列表
# 在给切片进行赋值时，只能使用序列
stus[0:2] = ['牛魔王', '红孩儿']  # 使用新的元素替换旧元素
print(stus)  # ['牛魔王', '红孩儿', '唐僧', '蜘蛛精', '白骨精']
stus[0:2] = ['牛魔王', '红孩儿', '二郎神', "sda"]  # 新元素的个数可以超过旧元素
print(stus)  # ['牛魔王', '红孩儿', '二郎神', 'sda', '唐僧', '蜘蛛精', '白骨精']
stus[0:0] = ['牛魔王']  # 向索引为 0 的位置插入元素
print(stus)  # ['牛魔王', '牛魔王', '红孩儿', '二郎神', 'sda', '唐僧', '蜘蛛精', '白骨精']

# 当设置了步长时，序列中元素的个数必须和切片中元素的个数一致
print(stus[::2])  # ['牛魔王', '红孩儿', 'sda', '蜘蛛精']，指定步长，切片中元素个数为 4
# stus[::2] = ['牛魔王', '红孩儿', '二郎神']  # 报错，序列中元素只有 3 个，ValueError: attempt to assign sequence of size 3 to extended slice of size 4

# 通过切片来删除元素
del stus[0:2]  # 删除头两个元素
print(stus)  # ['红孩儿', '二郎神', 'sda', '唐僧', '蜘蛛精', '白骨精']
del stus[::2]  # 隔一个删一个
print(stus)  # ['二郎神', '唐僧', '白骨精']
stus[1:3] = []  # 修改位置 1 和 2 的元素为空
print(stus)  # ['二郎神']

# 以上操作，只适用于可变序列
s = 'hello'
# s[1] = 'a'  # 不可变序列，无法通过索引来修改
# 可以通过 list() 函数将其他的序列转换为list
s = list(s)
print(s)  # ['h', 'e', 'l', 'l', 'o']
```

##### 列表的方法

示例：

```python
stus = ['孙悟空', '猪八戒', '沙和尚', '唐僧']

# append() 
# 向列表的最后添加一个元素
stus.append('唐僧1')
print(stus)  # ['孙悟空', '猪八戒', '沙和尚', '唐僧', '唐僧1']

# insert()
# 向列表的指定位置插入一个元素
# 参数：
#   1. 要插入的位置
#   2. 要插入的元素
stus.insert(2, '唐僧2')
print(stus)  # ['孙悟空', '猪八戒', '唐僧2', '沙和尚', '唐僧', '唐僧1']

# extend()
# 使用新的序列来扩展当前序列
# 需要一个序列作为参数，它会将该序列中的元素添加到当前列表中
stus.extend(['唐僧3', '白骨精'])  # 等同于：stus += ['唐僧3','白骨精']
print(stus)  # ['孙悟空', '猪八戒', '唐僧2', '沙和尚', '唐僧', '唐僧1', '唐僧3', '白骨精']

# pop()
# 根据索引删除并返回被删除的元素，如果不指定索引位置，则删除并返回最后一个元素
result = stus.pop(2)
print(result)  # 唐僧2
print(stus)  # ['孙悟空', '猪八戒', '沙和尚', '唐僧', '唐僧1', '唐僧3', '白骨精']
result = stus.pop()  # 删除并返回最后一个元素
print(result)  # 白骨精
print(stus)  # ['孙悟空', '猪八戒', '沙和尚', '唐僧', '唐僧1', '唐僧3']

# remove()
# 删除指定值的元素，如果相同值的元素有多个，只会删除第一个
stus.remove('猪八戒')
print(stus)  # ['孙悟空', '沙和尚', '唐僧', '唐僧1', '唐僧3']

# reverse()
# 用来反转列表
stus.reverse()
print(stus)  # ['唐僧3', '唐僧1', '唐僧', '沙和尚', '孙悟空']

# clear()
# 清空序列
stus.clear()
print(stus)  # []

# sort()
# 用来对列表中的元素进行排序，默认是升序排列
# 如果需要降序排列，则需要传递一个 reverse=True 作为参数
my_list = list('asnbdnbasdabd')
my_list.sort()
print(my_list)  # ['a', 'a', 'a', 'b', 'b', 'b', 'd', 'd', 'd', 'n', 'n', 's', 's']

my_list = [10, 1, 20, 3, 4, 5, 0, -2]
my_list.sort()
print(my_list)  # 升序：[-2, 0, 1, 3, 4, 5, 10, 20]
my_list.sort(reverse=True)
print(my_list)  # 降序：[20, 10, 5, 4, 3, 1, 0, -2]
```

##### 列表的遍历

示例：

```python
# 遍历列表，指的就是将列表中的所有元素取出来
# 创建列表
stus = ['孙悟空', '猪八戒', '沙和尚', '唐僧', '白骨精', '蜘蛛精']

# 遍历列表
# print(stus[0])
# print(stus[1])
# print(stus[2])
# print(stus[3])

# 通过 while 循环来遍历列表
i = 0
while i < len(stus):
    print(stus[i])
    i += 1

# 通过 for 循环来遍历列表
# 语法：
#   for 变量 in 序列 :
#       代码块
# for 循环的代码块会执行多次，序列中有几个元素就会执行几次
#   每执行一次就会将序列中的一个元素赋值给变量，所以我们可以通过变量，来获取列表中的元素
for s in stus:
    print(s)
```

##### 列表的可变对象说明

每个对象中都保存了三个数据：id（标识），type（类型）和 value（值）。

- **列表是一个可变对象**，比如 `a = [1, 2, 3]`。
- `a[0] = 10`：改对象。
  - 这个操作是在通过变量去修改对象的值。
  - 这种操作不会改变变量所指向的对象。
  - 当我们去修改对象时，如果有其他变量也指向了该对象，则修改也会在其他的变量中体现。

- `a = [4, 5, 6]`：改变量。
  - 这个操作是在给变量重新赋值。
  - 这种操作会改变变量所指向的对象。
  - 为一个变量重新赋值时，不会影响其他的变量。
- 一般只有在为变量赋值时才是修改变量，其余的都是修改对象。

示例：

```python
# 列表是可变对象
a = [1, 2, 3]
print('修改前：', a, id(a))  # 修改前： [1, 2, 3] 1322105181888

# 通过索引修改列表的值
a[0] = 10
print('修改后：', a, id(a))  # 修改后： [10, 2, 3] 1322105181888

# 为变量重新赋值
a = [4, 5, 6]
print('重新赋值：', a, id(a))  # 重新赋值： [4, 5, 6] 1322105180928

a = [1, 2, 3]
b = a  # a 和 b 指向同一个对象
print("a", a, id(a))  # a [1, 2, 3] 2222727763648
print("b", b, id(b))  # b [1, 2, 3] 2222727763648
b[0] = 10
print("a", a, id(a))  # a [10, 2, 3] 2222727763648
print("b", b, id(b))  # b [10, 2, 3] 2222727763648

b = [10, 2, 3]  # b 和 a 指向的不再是同一个对象
print("a", a, id(a))  # a [10, 2, 3] 2222727763648
print("b", b, id(b))  # b [10, 2, 3] 2222727762688
```

##### 二维列表

`二位列表`：列表中的元素是列表的列表。

示例：

```python
li1 = [
    [1, 2, 3], [4, 5, 6], [7, 8, 9]
]
print(li1[1][1])  # 5
```

#### 元组（tuple）

##### 元组的创建

语法：`元组名 = ()`。

- 创建一个空元组：`tuple_name = ()`。
- 创建一个包含元素的元组：`tuple_name = (value1, value2, value3, ...)`。
- 元组是一个不可变的序列，它的操作的方式基本上和列表是一致的。在操作元组时，可以把元组当成是一个不可变的列表。
- 元组是不可变对象，不能尝试为元组中的元素重新赋值。一般当我们希望数据不改变时，就使用元组，其余情况都使用列表。
- 当元组不是空元组时，括号可以省略。如果元组不是空元组，它里边至少要有一个`,`。

示例：

```python
my_tuple = ()  # 创建了一个空元组
print(my_tuple, type(my_tuple))  # () <class 'tuple'>

my_tuple = (1, 2, 3, 4, 5)  # 创建了一个 5 个元素的元组

# 元组是不可变对象，不能尝试为元组中的元素重新赋值
# my_tuple[3] = 10  # TypeError: 'tuple' object does not support item assignment
# print(my_tuple[3])

# 当元组不是空元组时，括号可以省略
# 如果元组不是空元组，它里边至少要有一个 ","
my_tuple = 10, 20, 30, 40
print(my_tuple, type(my_tuple))  # (10, 20, 30, 40) <class 'tuple'>
my_tuple = 40,
print(my_tuple, type(my_tuple))  # (40,) <class 'tuple'>
```

##### 元组的解包（解构）

**`解包`**：指的是将元组当中每一个元素都赋值给一个变量。

- 利用元组的解包特性，可以直接交换 a 和 b 的值。说明：不光是元组，列表和字符串都能解包。
- 在对一个元组进行解包时，变量的数量必须和元组中的元素的数量一致。也可以在变量前边添加一个`*`，这样该变量将会获取元组中所有剩余的元素，但不能同时出现两个或以上的 "*变量"。

示例：

```python
my_tuple = 10, 20, 30, 40

# 元组的解包（解构）
a, b, c, d = my_tuple
print("a =", a)  # a = 10
print("b =", b)  # b = 20
print("c =", c)  # c = 30
print("d =", d)  # d = 40

# 利用元组的解包特性，可以直接交换 a 和 b 的值
a = 100
b = 300
a, b = b, a  # b, a 就是一个元组，通过解包赋值给 a, b
print(a, b)  # 300 100

my_tuple = 10, 20, 30, 40

# 在对一个元组进行解包时，变量的数量必须和元组中的元素的数量一致
# 也可以在变量前边添加一个 *，这样该变量将会获取元组中所有剩余的元素
a, b, *c = my_tuple
a, *b, c = my_tuple
*a, b, c = my_tuple
a, b, *c = [1, 2, 3, 4, 5, 6, 7]  # 对列表也可以解包
a, b, *c = 'hello world'  # 对字符串也可以解包
# 不能同时出现两个或以上的 *变量
# *a, *b, c = my_tuple  # SyntaxError: two starred expressions in assignment
print('a =', a)  # a = h
print('b =', b)  # b = e
print('c =', c)  # c = ['l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
```

#### 字符串（str）

**`字符串`**：用来表示一段文本信息，字符串是程序中使用的最多的数据类型。

- **由字符组成的不可变序列。**
- 支持索引、切片和各种字符串操作方法。
- 字符串是以`单引号 ' 或双引号 "`括起来的任意文本（不要混用），比如 'abc'，"xyz" 等等。请注意，`''`或`""`本身只是一种表示方式，不是字符串的一部分，因此，字符串 'abc' 只有 a，b，c 这 3 个字符。如果`'`本身也是一个字符，那就可以用`""`括起来，比如 "I'm OK" 包含的字符是 I、'、m、空格、O、K 这 6 个字符。
- 相同的引号之间不能嵌套。如果字符串内部既包含 ' 又包含 "，可以用转义字符`\`来标识，比如 `'I\'m \"OK\"!'`。
- 如果字符串内部有很多换行，用`\n`写在一行里不好阅读，为了简化，Python 允许用`'''...'''`或`"""..."""`的格式表示多行内容。**三重引号中可以换行，并且会保留字符串中的格式。**

示例：

```python
>>> print('''line1
... line2
... line3''')
line1
line2
line3
>>> print(r'''hello,\n
... world''')
hello,\n
world
```

- 上面是在交互式命令行内输入，在输入多行内容时，提示符由`>>>`变为`...`，提示可以接着上一行输入，注意`...`是提示符，不是代码的一部分。

##### 字符串的转义

转义字符`\`可以转义很多字符。比如：`\t`表示制表符，`\n`表示换行符，`\uxxxx`表示 Unicode 编码，可以打印出一些特殊的符号。

```powershell
>>> print('I\'m ok.')
I'm ok.
>>> print('I\'m learning\nPython.')
I'm learning
Python.
>>> print('\\\n\\')
\
\
```

如果字符串里面有很多字符都需要转义，就需要加很多`\`，为了简化，Python 还允许用`r''`表示 ' ' 内部的字符串默认不转义。

```powershell
>>> print('\\\t\\')
\       \
>>> print(r'\\\t\\')
\\\t\\
```

##### 字符串的格式化

`拼串`：字符串之间可以进行**加法运算**，如果将两个字符串进行相加，则会自动将两个字符串拼接为一个。

```python
name = '孙悟空'

print('欢迎 ' + name + ' 光临！')  # 欢迎 孙悟空 光临！
```

`多参数`：字符串只能和字符串拼接，不能和其他的类型进行加法运算。print("a = " + a) 这种写法在 Python 中不常见，因为 a 可能不是字符串，容易出错，常写作 print('a = ', a)。

```python
name = '孙悟空'

print('欢迎 ', name, ' 光临！')  # 欢迎 孙悟空 光临！
```

`占位符`：在创建字符串时，可以在字符串中指定占位符，**`%s`在字符串中表示任意字符，`%f`表示浮点数占位符，`%d`表示整数占位符。**

```python
b = 'Hello %s' % '孙悟空'  # 一个占位符：Hello 孙悟空
b = 'hello %s 你好 %s' % ('tom', '孙悟空')  # 两个占位符：hello tom 你好 孙悟空
b = 'hello %3s' % 'ab'  # 占位符处的字符串长度至少为 3，不足 3 的，在前面填充空格：hello  ab
b = 'hello %3.5s' % 'abcdefg'  # 占位符处的字符串的长度限制在 3 ~ 5 之间：hello abcde
b = 'hello %.2f' % 123.456  # 保留 2 位小数，四舍五入：hello 123.46
b = 'hello %d' % 123.95  # 直接舍弃小数位：hello 123

print(b)
```

`格式化字符串`：可以通过**在字符串前添加一个`f`来创建一个格式化字符串，在格式化字符串中可以直接嵌入变量**。

```python
a = 123
b = '呵呵'
c = f'hello {a} {b}'

print(f'a = {a}')  # a = 123
print(c)  # hello 123 呵呵
```

##### 字符串的复制

将字符串和数字相乘，`*`在语言中表示乘法，如果将字符串和数字相乘，则解释器会将字符串重复指定的次数并返回。

```python
a = 'abc'
a = a * 5

print(a)  # abcabcabcabcabc
```

##### 字符串的索引

可以使用`索引`获取一个字符串中 指定位置的字符，索引计数从 0 开始。

![1727535125786](https://img2023.cnblogs.com/blog/3488201/202409/3488201-20240928234347080-22780188.jpg)

示例：

```python
a = 'hello, world'
print(a[0], a[-1])  # h d
```

## 字典（dict）

### 字典的概念

**`字典`**：属于一种新的数据结构，称为**映射（mapping）**，**由键值对组成的无序集合**，其中键必须是唯一的且不可变的，值可以是任意类型。

- 字典的作用和列表类似，都是用来存储对象的容器。
- 列表存储数据的性能很好，但是查询数据的性能的很差。查询元素时，字典的效率是非常快的。
- 在字典中可以保存多个对象，每个对象都会有一个唯一的名字，通过这个唯一的名字可以快速的查找到指定的元素。
  - 这个唯一的名字，我们称其为`键（key）`，通过 key 可以快速的查询 value。
  - 这个对象，我们称其为`值（value）`。
  - 所以字典，我们也称为**键值对（key - value）结构**。
  - 每个字典中都可以有多个键值对，而每一个键值对我们称其为**一项（item）**。

### 字典的创建

语法一：`字典名 = {}`。

语法二：使用`dict()`函数。

- 创建一个空字典：`dict_name = {}`。
- 创建一个包含数据的字典：`dict_name = {k1: v1, k2: v2, k3: v3, ...}`。
- 字典的键可以是任意的不可变对象（int、str、bool、tuple ...），但是一般我们都会使用 str。
- **字典的键是不能重复的**，如果出现重复，后边的会替换前边的。
- 字典的值可以是任意对象。

示例：

```python
# 方式一：使用 {} 来创建字典

d = {}  # 创建一个空字典

# 创建一个包含有数据的字典
d = {
    'name': '孙悟空',
    'age': 18,
    'gender': '男'
}
print(d, type(d))  # {'name': '孙悟空', 'age': 18, 'gender': '男'} <class 'dict'>

# 根据键来获取值
print(d['name'], d['age'], d['gender'])  # 孙悟空 18 男

# 如果使用了字典中不存在的键，会报错
# print(d['hello'])  # KeyError: 'hello'

############################################################################

# 方式二：使用 dict() 函数来创建字典

# 每一个参数都是一个键值对，参数名就是键，参数名就是值（这种方式创建的字典，key 都是字符串）
d = dict(name='孙悟空', age=18, gender='男')

# 也可以将一个包含有双值子序列的序列转换为字典
#   双值序列：序列中只有两个值，比如[1, 2]，('a', 3)，'ab'
#   子序列：如果序列中的元素也是序列，那么我们就称这个元素为子序列，比如[(1, 2), (3, 5)]
d = dict([('name', '孙悟空'), ('age', 18)])
```

### 字典的使用

```python
d = dict(name='孙悟空', age=18, gender='男')

# len()：获取字典中键值对的个数
print(len(d))  # 3

# in：检查字典中是否包含指定的键
# not in：检查字典中是否不包含指定的键
print('hello' in d)  # False
print('age' not in d)  # False

# 获取字典中的值，根据键来获取值
# 方式一：d[key]
#   通过 d[key] 来获取值时，如果键不存在，会抛出异常 KeyError
print(d['age'])  # 18
n = 'name'
print(d[n])  # 孙悟空

# 方式二：get(key[, default])，该方法用来根据键来获取字典中的值
#   如果获取的键在字典中不存在，会返回 None，不会报错
#   也可以指定一个默认值，来作为第二个参数，这样获取不到值时将会返回默认值
print(d.get('name'))  # 孙悟空
print(d.get('hello'))  # None
print(d.get('hello', '默认值'))  # 默认值

# 修改字典
# d[key] = value：如果 key 存在则覆盖，不存在则添加
d['name'] = 'sunwukong'  # 修改字典的 key-value
d['address'] = '花果山'  # 向字典中添加 key-value

# setdefault(key[, default])：可以用来向字典中添加 key-value
#   如果 key 已经存在于字典中，则返回 key 的值，不会对字典做任何操作
#   如果 key 不存在，则向字典中添加这个 key，并设置 value
result = d.setdefault('name', '猪八戒')
print('result =', result)  # result = sunwukong
result = d.setdefault('hello', '猪八戒')
print(d)  # {'name': 'sunwukong', 'age': 18, 'gender': '男', 'address': '花果山', 'hello': '猪八戒'}

# update([other])：将其他的字典中的 key-value 添加到当前字典中
#   如果有重复的 key，则后边的会替换到当前的
d = {'a': 1, 'b': 2, 'c': 3}
d2 = {'d': 4, 'e': 5, 'f': 6, 'a': 7}
d.update(d2)
print(d)  # {'a': 7, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}

# del：删除字典中的 key-value
del d['a']
del d['b']
print(d)  # {'c': 3, 'd': 4, 'e': 5, 'f': 6}
# del d['z']  # z 不存在，报错，KeyError: 'z'

# popitem()：随机删除字典中的一个键值对，一般都会删除最后一个键值对
#   删除之后，它会将删除的 key-value 作为返回值返回
#   返回的是一个元组，元组中有两个元素，第一个元素是删除的 key，第二个是删除的 value
#   当使用 popitem() 删除一个空字典时，会抛出异常 KeyError: 'popitem(): dictionary is empty'
# d.popitem()
result = d.popitem()
print(result)  # ('f', 6)
print(d)  # {'c': 3, 'd': 4, 'e': 5}

# pop(key[, default])：根据 key 删除字典中的 key-value，并将被删除的 value 返回
#   如果删除不存在的 key，会抛出异常
#   如果指定了默认值，再删除不存在的 key 时，不会报错，而是直接返回默认值
result = d.pop('d')
print(result)  # 4
print(d)  # {'c': 3, 'e': 5}
result = d.pop('z', '这是默认值')
print(result)  # 这是默认值
print(d)  # {'c': 3, 'e': 5}

# clear()：清空字典
d.clear()
print(d)  # {}

# print('result =',result)
# print(d)

# copy()：该方法用于对字典进行浅复制
#   复制以后的对象，和原对象是独立的，修改一个不会影响另一个
d = {'a': 1, 'b': 2, 'c': 3}
d2 = d.copy()  # d 和 d2 指向的是两个对象，这两个对象的值相同，id 不同
print('d = ', d, id(d))  # d =  {'a': 1, 'b': 2, 'c': 3} 1507616638400
print('d2 = ', d2, id(d2))  # d2 =  {'a': 1, 'b': 2, 'c': 3} 1507616638464

# 注意，浅复制会简单复制对象内部的值，如果值也是一个可变对象，这个可变对象不会被复制
# 深复制性能差，使用较少
d = {'a': {'name': '孙悟空', 'age': 18}, 'b': 2, 'c': 3}
d2 = d.copy()
print('d = ', d, id(d))  # d =  {'a': {'name': '孙悟空', 'age': 18}, 'b': 2, 'c': 3} 2538203734848
print('d2 = ', d2, id(d2))  # d2 =  {'a': {'name': '孙悟空', 'age': 18}, 'b': 2, 'c': 3} 2538210096768
# d 的 a 值也是一个字典，修改 d2 中 a 值列表中 name 的值，d 也会受到影响，说明浅复制不修改是可变对象的值
d2['a']['name'] = '猪八戒'
print('d = ', d, id(d))  # d =  {'a': {'name': '猪八戒', 'age': 18}, 'b': 2, 'c': 3} 2538203734848
print('d2 = ', d2, id(d2))  # d2 =  {'a': {'name': '猪八戒', 'age': 18}, 'b': 2, 'c': 3} 2538210096768

# d 的 a 值是一个列表
d = {'a': ['孙悟空', '猪八戒', '沙和尚'], 'b': 2, 'c': 3}
d2 = d.copy()
print('d = ', d, id(d))  # d =  {'a': ['孙悟空', '猪八戒', '沙和尚'], 'b': 2, 'c': 3} 2053189928960
print('d2 = ', d2, id(d2))  # d2 =  {'a': ['孙悟空', '猪八戒', '沙和尚'], 'b': 2, 'c': 3} 2053187068736
d2['a'][0] = '唐僧'
print('d = ', d, id(d))  # d =  {'a': ['唐僧', '猪八戒', '沙和尚'], 'b': 2, 'c': 3} 2053189928960
print('d2 = ', d2, id(d2))  # d2 =  {'a': ['唐僧', '猪八戒', '沙和尚'], 'b': 2, 'c': 3} 2053187068736
```

### 字典的遍历

```python
d = {'name': '孙悟空', 'age': 18, 'gender': '男'}

# 方式一：keys()
#   该方法会返回一个序列，序列中是字典中所有的键
for k in d.keys():
    print(k, d[k])

# 方式二：values()
#   该方法会返回一个序列，序列中是字典中所有的值
for v in d.values():
    print(v)

# 方式三：items()
#   该方法会返回字典中所有的项，它会返回一个序列，序列中是双值子序列
#   双值分别是，字典中的 key 和 value
print(d.items())  # dict_items([('name', '孙悟空'), ('age', 18), ('gender', '男')])
for k, v in d.items(): # 元组解包特性
    print(k, '=', v)
```

## 集合（set）

### 集合的概念

**`集合`**：和列表非常相似。

不同点：

- 集合中**只能存储不可变对象**。
- 集合中存储的对象是**无序**的（不是按照元素的插入顺序保存）。
- 集合中**不能出现重复的元素**。

> **冻结集合（frozenset）**：
>
> - 不可变的集合，一旦创建就不能修改。
> - 用`frozenset()`函数创建。
>
> 示例：
>
> ```python
> l = frozenset([1, 2, 3])
> print(l, type(l))  # frozenset({1, 2, 3}) <class 'frozenset'>
> ```

### 集合的创建

语法一：`集合名 = {}`。

语法二：使用`set()`函数。

- **空集合只能通过 set() 来创建，{} 创建的是空字典。**

示例：

```python
# 方式一：使用 {} 来创建集合
s = {10, 3, 5, 1, 2, 1, 2, 3, 1, 1, 1, 1}
print(s, type(s))  # {1, 2, 3, 5, 10} <class 'set'>
# s = {[1, 2, 3], [4, 6, 7]}  # TypeError: unhashable type: 'list'，集合中只能存储不可变对象

############################################################################

# 方式二：使用 set() 函数来创建集合
s = set()  # 空集合只能通过 set() 来创建，{} 创建的是字典
# 可以通过 set() 来将序列和字典转换为集合
s = set([1, 2, 3, 4, 5, 1, 1, 2, 3, 4, 5])  # 转换列表
print(s)  # {1, 2, 3, 4, 5}
s = set('hello')  # 转换字符串
print(s)  # {'e', 'h', 'o', 'l'}
s = set({'a': 1, 'b': 2, 'c': 3})  # 转换字典，使用 set() 将字典转换为集合时，只会包含字典中的键
print(s)  # {'b', 'a', 'c'}
```

### 集合的使用

```python
############################################################################
s = {'a', 'b', 1, 2, 3, 1}
print(s)  # {1, 2, 3, 'a', 'b'}

# 使用 in 和 not in 来检查集合中的元素
print('a' in s)  # True
print('b' not in s)  # False

# 使用 len() 来获取集合中元素的数量
print(len(s))  # 5

# add()：向集合中添加元素
s.add(10)
s.add(30)
s.add(1)  # 集合中已存在的元素，添加无效
print(s)  # {1, 2, 3, 'a', 10, 'b', 30}

############################################################################
s = {'a', 'b', 1, 2, 3}

# update()：可以将一个集合中的元素添加到当前集合中，也可以传递序列或字典作为参数，字典只会添加键倒集合中
s2 = set('hello')  # 集合
s.update(s2)
print(s)  # {'a', 2, 3, 1, 'h', 'o', 'l', 'e', 'b'}

s = {'a', 'b', 1, 2, 3}
s.update((10, 20, 30, 40, 50))  # 元组
print(s)  # {'a', 2, 3, 1, 40, 10, 50, 20, 'b', 30}

s = {'a', 'b', 1, 2, 3}
s.update({10: 'ab', 20: 'bc', 100: 'cd', 1000: 'ef'})  # 字典
print(s)  # {'a', 2, 3, 1, 100, 1000, 10, 20, 'b'}

############################################################################
s = {'a', 'b', 1, 2, 3}

# {1, 2, 3, 100, 40, 'o', 10, 1000, 'a', 'h', 'b', 'l', 20, 50, 'e', 30}
# pop()：随机删除并返回一个集合中的元素
result = s.pop()
print(result)  # 1
print(s)  # {'a', 3, 2, 'b'}

# remove()：删除集合中的指定元素
s.remove('a')
print(s)  # {2, 3, 'b'}

# clear()：清空集合
s.clear()
print(s)  # set()

# copy()：对集合进行浅复制
```

### 集合的运算

在对集合做运算时，不会影响原来的集合，而是返回一个运算结果。

```python
# 创建两个集合
s = {1, 2, 3, 4, 5}
s2 = {3, 4, 5, 6, 7}

# &：交集运算
result = s & s2
print(result)  # {3, 4, 5}

# | 并集运算
result = s | s2
print(result)  # {1, 2, 3, 4, 5, 6, 7}

# -：差集
result = s - s2
print(result)  # {1, 2}

# ^：异或集，获取两个集合中只出现一次的元素
result = s ^ s2
print(result)  # {1, 2, 6, 7}

# <=：检查一个集合是否是另一个集合的子集
#   如果 a 集合中的元素全部都在 b 集合中出现，那么 a 集合就是 b 集合的子集，b 集合是 a 集合的超集
a = {1, 2, 3}
b = {1, 2, 3, 4, 5}
result = a <= b
print(result)  # True
result = {1, 2, 3} <= {1, 2, 3}
print(result)  # True
result = {1, 2, 3, 4, 5} <= {1, 2, 3}
print(result)  # False

# <：检查一个集合是否是另一个集合的真子集
#   如果超集 b 中含有子集 a 中所有元素，并且 b 中还有 a 中没有的元素，则 b 就是 a 的真超集，a 是 b 的真子集
result = {1, 2, 3} < {1, 2, 3}
print(result)  # False
result = {1, 2, 3} < {1, 2, 3, 4, 5}
print(result)  # True

# >=：检查一个集合是否是另一个的超集
result = {1, 2, 3, 4, 5} >= {1, 2, 3, 4, 5}
print(result)  # True

# >：检查一个集合是否是另一个的真超集
result = {1, 2, 3, 4, 5} > {1, 2, 3, 4, 5}
print(result)  # False
```

## 其他类型

### 布尔类型（bool）

**`布尔值`**：布尔值和布尔代数的表示完全一致，一个布尔值只有`True`、`False`两种值，要么是 True，要么是 False。

- 在 Python 中，能够解释为假的值有：**None、0、0.0、False、所有的空容器（空列表、空元组、空字符串、空字典、空集合）。**

- 在 Python 中，可以直接用 True、False 表示布尔值（请注意大小写），也可以通过布尔运算计算出来。

  ```powershell
  >>> True
  True
  >>> False
  False
  >>> 3 > 2
  True
  >>> 2 > 5
  False
  ```

- 布尔值可以用`and`、`or` 和`not`运算。

  - **and 运算是与运算**，只有所有都为 True，and 运算结果才是 True。

    ```powershell
    >>> True and True
    True
    >>> True and False
    False
    >>> False and True
    False
    >>> False and False
    False
    >>> 5 > 3 and 3 > 1
    True
    ```

  - **or 运算是或运算**，只要其中有一个为 True，or 运算结果就是 True。

    ```powershell
    >>> True or True
    True
    >>> True or False
    True
    >>> False or True
    True
    >>> False or False
    False
    >>> 5 > 3 or 1 > 3
    True
    ```

  - **not 运算是非运算**，它是一个单目运算符，把 True 变成 False，False 变成 True。

    ```powershell
    >>> not True
    False
    >>> not False
    True
    >>> not 5 > 3
    False
    ```

- 布尔值经常用在条件判断中，比如：

  ```python
  if age >= 18:
      print('adult')
  else:
      print('teenager')
  ```

- 布尔值实际上也属于整型，**True 就相当于 1，False 就相当于 0。**

  ```python
  print(1 + False)  # 1
  print(1 + True)  # 2
  ```

### None 类型

**`空值`**：是 Python 里一个特殊的值，用`None`表示。None 不能理解为 0，因为 0 是有意义的，而 None 是一个特殊的空值。

## 原文链接

https://github.com/ACatSmiling/zero-to-zero/blob/main/PythonLanguage/python.md